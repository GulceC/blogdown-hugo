<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>one-liner | Assoc.Prof.Dr. Alper YILMAZ</title><link>http://alperyilmaz.site/tag/one-liner/</link><atom:link href="http://alperyilmaz.site/tag/one-liner/index.xml" rel="self" type="application/rss+xml"/><description>one-liner</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Â© 2021</copyright><lastBuildDate>Thu, 07 Jul 2011 09:33:37 +0000</lastBuildDate><image><url>http://alperyilmaz.site/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_3.png</url><title>one-liner</title><link>http://alperyilmaz.site/tag/one-liner/</link></image><item><title>Transpose a matrix with perl nested map</title><link>http://alperyilmaz.site/post/2011-07-07-transpose-a-matrix-with-perl-nested-map/</link><pubDate>Thu, 07 Jul 2011 09:33:37 +0000</pubDate><guid>http://alperyilmaz.site/post/2011-07-07-transpose-a-matrix-with-perl-nested-map/</guid><description>&lt;p>Here&amp;rsquo;s the matrix that we&amp;rsquo;ll be using:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ paste &amp;lt;(seq 1 5) &amp;lt;(seq 12 16)
1 12
2 13
3 14
4 15
5 16
&lt;/code>&lt;/pre>
&lt;p>Now, let&amp;rsquo;s use a perl one-liner with nested maps to transpose the matrix:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ paste &amp;lt;(seq 1 5) &amp;lt;(seq 12 16) | perl -ane 'push @matrix,[@F]; END { print join &amp;quot;\n&amp;quot;,map {$row=$_; join&amp;quot;\t&amp;quot;,map { $matrix[$_][$row]} 0 .. $#matrix } 0 .. $#{$matrix[0]}; print &amp;quot;\n&amp;quot; }'
1 2 3 4 5
12 13 14 15 16
&lt;/code>&lt;/pre>
&lt;p>I got the idea from this &lt;a href="http://www.hidemail.de/blog/perl_tutor.shtml#map_transpose_matrix" target="_blank" rel="noopener">blog post&lt;/a>, but I slightly modified it so that you don&amp;rsquo;t need to make a copy of the transposed array (to save memory)&lt;/p></description></item><item><title>Extract intervals from an array of numbers</title><link>http://alperyilmaz.site/post/2011-06-27-extract-intervals-from-an-array-of-numbers/</link><pubDate>Mon, 27 Jun 2011 06:58:02 +0000</pubDate><guid>http://alperyilmaz.site/post/2011-06-27-extract-intervals-from-an-array-of-numbers/</guid><description>&lt;p>Let&amp;rsquo;s assume you have an array of numbers and you want to extract intervals from this array. For example, from such an array: 2,3,4,5,8,9,10,11,12,15,18,19,20 you should be getting (2-5), (8-12), (18-20) as intervals.&lt;/p>
&lt;p>More bioinformatic case: Let&amp;rsquo;s assume you ran samtools pileup format and want to extract intervals from the genomic coordinates that has at least one hit.&lt;/p>
&lt;p>The following one-liner will give you what you want: (I used &lt;code>seq&lt;/code> to generate array of numbers and concatenated multiple seq)&lt;/p>
&lt;pre>&lt;code class="language-bash">cat &amp;lt;(seq 3 23) &amp;lt;(echo 25) &amp;lt;(seq 40 50) | perl -ne 'BEGIN{our $i=1}; chomp ; if(($_ - (${$hash-&amp;gt;{$i-1}}[-1]))==1){push @{$hash-&amp;gt;{$i-1}},$_}else{push @{$hash-&amp;gt;{$i++}},$_}; END {print join&amp;quot;\n&amp;quot;, map {${$hash-&amp;gt;{$_}}[0].&amp;quot;\t&amp;quot;.${$hash-&amp;gt;{$_}}[-1]} grep { scalar(@{$hash-&amp;gt;{$_}}) &amp;gt; 1} sort {$a &amp;lt;=&amp;gt; $b} keys %$hash; print &amp;quot;\n&amp;quot;}'
&lt;/code>&lt;/pre>
&lt;p>And the result is:&lt;/p>
&lt;pre>&lt;code class="language-txt">3 23
40 50
&lt;/code>&lt;/pre>
&lt;p>&lt;code>map&lt;/code> was used to get first and last element of array, &lt;code>grep&lt;/code> is used to filter out arrays that has less than 2 elements.&lt;/p></description></item><item><title>Extract upstream region sequence with bedtools</title><link>http://alperyilmaz.site/post/2011-03-06-extract-upstream-region-sequence-with-bedtools/</link><pubDate>Sun, 06 Mar 2011 08:40:36 +0000</pubDate><guid>http://alperyilmaz.site/post/2011-03-06-extract-upstream-region-sequence-with-bedtools/</guid><description>&lt;p>Soon after SAM/BAM format became standard for short-read alignment softwares, high caliber tools have been emerging that can process the widely accepted format. &lt;a href="http://code.google.com/p/bedtools/" target="_blank" rel="noopener">bedtools&lt;/a> is one of them and it&amp;rsquo;s easy to use and flexible. Most importantly you can integrate it with commandline pipes.&lt;/p>
&lt;p>In this post, I&amp;rsquo;ll be describing how to extract upstream region sequences with the help of bedtools. I&amp;rsquo;ll be using the following files in my sample:&lt;/p>
&lt;p>File1: small-chr-genes.bed (holds locations of genes)&lt;/p>
&lt;pre>&lt;code class="language-txt">1 10 20 gene1 0 +
1 40 50 gene2 0 -
&lt;/code>&lt;/pre>
&lt;p>File2: small-chr.fa (genome sequence file)&lt;/p>
&lt;pre>&lt;code class="language-txt">&amp;gt;1
GCGACTACGACTACAGCACTACGACATCAGCACTACGACT
ACGACTACGACATCACGACACACGACGACATCACGACTAC
&lt;/code>&lt;/pre>
&lt;p>File3: small-chr.genome (genome file which contains name and length of each chromosome)&lt;/p>
&lt;pre>&lt;code class="language-txt">1 80
&lt;/code>&lt;/pre>
&lt;p>The one-liner below extracts 5 basepairs upstream region for each gene and slopBed takes care of strand issues (reverse complement of extracted sequence if gene is on negative strand) and genome size issues (trim the extracted sequence if gene is close to beginning or end of chromosome).&lt;/p>
&lt;pre>&lt;code class="language-bash">slopBed -i small-chr-genes.bed -g small-chr.genome -l 5 -r 0 -s | perl -ane '($F[5] eq &amp;quot;+&amp;quot;)? $F[2]=$F[1] : $F[1]=$F[2]; print join&amp;quot;\t&amp;quot;,@F;print&amp;quot;\n&amp;quot;' | slopBed -i stdin -g small-chr.genome -l 0 -r 5 -s | fastaFromBed -fi small-chr.fa -bed stdin -fo stdout -name -s
&lt;/code>&lt;/pre>
&lt;p>The output looks like this:&lt;/p>
&lt;pre>&lt;code class="language-txt">&amp;gt;gene1
TACGA
&amp;gt;gene2
TGATG
&lt;/code>&lt;/pre>
&lt;p>Let me try to explain how it works, first I extend each gene 5 basepair to its upstream. Then I mark the beginning of the extended region by converting it into single nucleotide region. I use slopBed again, to extend from the mark in opposite direction for 5 basepairs. Now we have the upstream region start and end coordinates, and by the help of fastaFromBed, the upstream region sequence was extracted from genome sequence.&lt;/p>
&lt;p>bedtools has a tool named subtractBed and I was thinking that combination of slopBed, subtractBed and fastaFromBed should be the solution. However, probably due to genes that are overlapping, subtracting gene region from extended region didn&amp;rsquo;t work as well as I expected. That&amp;rsquo;s why I integrated a perl one-liner to take care of subtracting the gene region from extended region.&lt;/p>
&lt;p>&lt;strong>Update&lt;/strong> : bedtools developer &lt;a href="http://obx.cphg.virginia.edu/quinlan/" target="_blank" rel="noopener">Aaron Quinlan&lt;/a> was kind enough to develop a new tool to accomplish the task described above. &amp;ldquo;flankBed&amp;rdquo; does exactly what is described above and it&amp;rsquo;s much simpler. Here&amp;rsquo;s the flankBed equivalent of extracting upstream regions:&lt;/p>
&lt;pre>&lt;code class="language-bash">flankBed -i small-chr-genes.bed -g small-chr.genome -l 5 -r 0 -s | fastaFromBed -fi small-chr.fa -bed stdin -fo stdout -name -s
&lt;/code>&lt;/pre></description></item><item><title>Plot one-liner generated data with gnuplot</title><link>http://alperyilmaz.site/post/2010-10-16-plot-one-liner-generated-data-with-gnuplot/</link><pubDate>Sat, 16 Oct 2010 22:13:24 +0000</pubDate><guid>http://alperyilmaz.site/post/2010-10-16-plot-one-liner-generated-data-with-gnuplot/</guid><description>&lt;p>In this post, I&amp;rsquo;ll demonstrate how to use gnuplot in a one-liner. We&amp;rsquo;ll use the pipe but unfortunately you cannot pipe raw data to gnuplot directly (as far as I know). The piped data should contain basic gnuplot commands on top. So, we&amp;rsquo;ll use the following template:&lt;/p>
&lt;pre>&lt;code class="language-bash">very-complicated-data-generating-commands | sed -e &amp;quot;1i\plot '-' &amp;quot; | gnuplot -persist
&lt;/code>&lt;/pre>
&lt;p>If you&amp;rsquo;re interested in quickly see how this works, try something simple:&lt;/p>
&lt;pre>&lt;code class="language-bash">seq 1 10 | sed -e &amp;quot;1i\plot '-'&amp;quot; | gnuplot -persist
&lt;/code>&lt;/pre>
&lt;p>Before sed command, you can write as complicated as possible command to generate data and inside sed command you can put long gnuplot commands to obtain graphs. Let&amp;rsquo;s see the counts of most used 20 commands from history (mentioned in an &lt;a href="http://alperyilmaz.site/post/2010-04-08-most-used-commands-in-history/">earlier post&lt;/a> with bar chart.&lt;/p>
&lt;pre>&lt;code class="language-bash">cat ~/.bash_history|grep -v &amp;quot;^#&amp;quot; | perl -F&amp;quot;\||&amp;lt;\(|;|\`|\\$\(&amp;quot; -alne 'foreach (@F) { print $1 if /^.*?(\w+)\b/i }' | sort | uniq -c | sort -nr | head -20 | awk '{print $2&amp;quot;\t&amp;quot;$1}' | sed -e &amp;quot;1i\set boxwidth 0.5\nset style fill solid noborder\nset xtics nomirror rotate by -60\nset format x '-%s'\nplot '-' using 2:xticlabels(1) with boxes notitle&amp;quot; | gnuplot -persist
&lt;/code>&lt;/pre>
&lt;p>Resulting image looks like this:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="http://alperyilmaz.site/img/history-top-occur-graph550x350.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>If you want to save the output in png format, what you do is simply add the command &lt;code>set term png size 600,300&lt;/code> to your one-liner. I chose width 600px and height 300px as example. In this case, gnuplot prints the contents of png file to screen, so we need to direct it to a filename, as shown below:&lt;/p>
&lt;pre>&lt;code class="language-bash">cat ~/.bash_history|grep -v &amp;quot;^#&amp;quot; | perl -F&amp;quot;\||&amp;lt;\(|;|\`|\\$\(&amp;quot; -alne 'foreach (@F) { print $1 if /^.*?(\w+)\b/i }' | sort | uniq -c | sort -nr | head -20 | awk '{print $2&amp;quot;\t&amp;quot;$1}' | sed -e &amp;quot;1i\set term png size 600,350\nset boxwidth 0.5\nset style fill solid noborder\nset xtics nomirror rotate by -60\nset format x '-%s'\nplot '-' using 2:xticlabels(1) with boxes notitle&amp;quot; | gnuplot &amp;gt; sample_image.png
&lt;/code>&lt;/pre></description></item><item><title>perl one-liner to pick random sequences from fasta file</title><link>http://alperyilmaz.site/post/2010-07-15-perl-one-liner-to-pick-random-sequences-from-fasta-file/</link><pubDate>Thu, 15 Jul 2010 08:03:53 +0000</pubDate><guid>http://alperyilmaz.site/post/2010-07-15-perl-one-liner-to-pick-random-sequences-from-fasta-file/</guid><description>&lt;p>In an earlier [post]({{ ref &amp;ldquo;post/perl-one-liner-to-process-sequence-files-in-stream.md&amp;rdquo; }}) we learned how to use Bio::SeqIO module to process fasta files with one-liner. Let&amp;rsquo;s do more with this capability. What about selecting random sequences from a fasta file?&lt;/p>
&lt;p>To achieve that, we&amp;rsquo;ll load the fasta file contents into a hash and then utilize the fact that &lt;code>rand(@array)&lt;/code> returns index of a random element from that array.&lt;/p>
&lt;p>Let&amp;rsquo;s pick 100 random sequences from a fasta file with one-liner:&lt;/p>
&lt;pre>&lt;code class="language-bash">.. fasta file stream .. | perl -MBio::SeqIO -e '$seq=Bio::SeqIO-&amp;gt;new(-fh =&amp;gt; \*STDIN);while ($myseq=$seq-&amp;gt;next_seq){ $hash{$myseq-&amp;gt;id}=$myseq-&amp;gt;seq }; END{@ids = keys %hash; foreach (1..100){my $index=rand(@ids); print &amp;quot;&amp;gt;&amp;quot;,$ids[$index],&amp;quot;\n&amp;quot;,$hash{$ids[$index]},&amp;quot;\n&amp;quot; } }'
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>UPDATE&lt;/strong>: If this one-liner throws problem about first sequence, please indicate the format of the input. Since read ahead is not possible in a pipe, the format might not be guessed correctly. So, please update the one-liner with this: &lt;code>$seq=Bio::SeqIO-&amp;gt;new(-fh =&amp;gt; \*STDIN, -format=&amp;gt;&amp;quot;fasta&amp;quot;)&lt;/code>&lt;/p></description></item><item><title>Way more practical one-liners with perl5i</title><link>http://alperyilmaz.site/post/2010-04-26-way-more-practical-one-liners-with-perl5i/</link><pubDate>Mon, 26 Apr 2010 23:48:05 +0000</pubDate><guid>http://alperyilmaz.site/post/2010-04-26-way-more-practical-one-liners-with-perl5i/</guid><description>&lt;p>&lt;a href="http://search.cpan.org/dist/perl5i/lib/perl5i.pm" target="_blank" rel="noopener">perl5i&lt;/a> project explains itself as &amp;ldquo;Perl 5 has a lot of warts, fix as much of it as possible in one pragma&amp;rdquo;. You can run your scripts with it by including perl5i (ie, use perl5i;). Best part is, it can be run at commandline with &lt;code>$ perl5i -e&lt;/code> .&lt;/p>
&lt;p>perl5i includes &lt;a href="http://search.cpan.org/~swalters/autobox-Core-1.2/" target="_blank" rel="noopener">Autobox module&lt;/a> which lets you call methods on primitive datatypes such as scalars and arrays (eg. &amp;ldquo;hello world&amp;rdquo;-&amp;gt;print). This feature allows constructing very compact one-liners as shown below:&lt;/p>
&lt;pre>&lt;code class="language-bash">perl5i -e 'my @arr = ( 1 .. 10 ); @arr-&amp;gt;map(sub {$_ ** 4 })-&amp;gt;grep(sub { $_ &amp;gt; 3 })-&amp;gt;sum-&amp;gt;say'
&lt;/code>&lt;/pre>
&lt;p>Explanation: calculate to the 4th power for each element of @arr. Of those 4th power numbers, filter out the ones smaller than 3. Then sum up the new array and print the result.&lt;/p>
&lt;pre>&lt;code class="language-bash">perl5i -e 'my @test=(1,2,3,4); my @compare=(2,4,6); @test-&amp;gt;intersect(\@compare)-&amp;gt;size-&amp;gt;concat(&amp;quot;\t&amp;quot;)-&amp;gt;print'
&lt;/code>&lt;/pre>
&lt;p>Explanation: Find the intersection of two arrays (assigned to new array) and add tab character to size of (intersection) array and then print it.&lt;/p>
&lt;pre>&lt;code class="language-bash">perl5i -e ' my $hashref = { foo =&amp;gt; 10, bar =&amp;gt; 20, baz =&amp;gt; 30, quux =&amp;gt; 40 }; $hashref-&amp;gt;values-&amp;gt;sort-&amp;gt;join(&amp;quot;-&amp;quot;)-&amp;gt;say'
&lt;/code>&lt;/pre>
&lt;p>Explanation: sort the values of hash and print them by joining with &amp;ldquo;-&amp;rdquo; character.&lt;/p></description></item><item><title>Most used commands in history</title><link>http://alperyilmaz.site/post/2010-04-08-most-used-commands-in-history/</link><pubDate>Thu, 08 Apr 2010 09:11:53 +0000</pubDate><guid>http://alperyilmaz.site/post/2010-04-08-most-used-commands-in-history/</guid><description>&lt;p>Most of the &amp;ldquo;most used commands&amp;rdquo; approaches does not consider pipes and other complexities.&lt;/p>
&lt;p>This approach considers pipes, process substitution by backticks or &lt;code>$()&lt;/code> and multiple commands separated by &lt;code>;&lt;/code>&lt;/p>
&lt;p>Perl regular expression breaks up each line using &lt;code>|&lt;/code> or &lt;code>&amp;lt;(&lt;/code> or &lt;code>;&lt;/code> or ` or &lt;code>$(&lt;/code> and picks the first word (excluding &amp;ldquo;do&amp;rdquo; in case of for loops)&lt;/p>
&lt;pre>&lt;code class="language-bash">history | perl -F&amp;quot;\||&amp;lt;\(|;|\`|\\$\(&amp;quot; -alne 'foreach (@F) { print $1 if /\b((?!do)[a-z]+)\b/i }' | sort | uniq -c | sort -nr | head
&lt;/code>&lt;/pre>
&lt;p>Let&amp;rsquo;s generate a fake history file which looks like this:&lt;/p>
&lt;pre>&lt;code class="language-txt">1 command file | command file | command | command
2 command &amp;lt;(command file) &amp;lt;(command file)
3 command file &amp;gt; file
4 for i in `command file`; do command file; command file; done | command
5 for i in $(command file); do command file; command file | command; done
&lt;/code>&lt;/pre>
&lt;p>This approach successfully counts 16 occurrences of &amp;ldquo;command&amp;rdquo; and 2 occurrences of &amp;ldquo;for&amp;rdquo;.&lt;/p>
&lt;p>Note: if you are using lots of perl one-liners, the perl commands/functions will be counted as well in this approach, since semicolon is used as a separator&lt;/p></description></item><item><title>One line statistics</title><link>http://alperyilmaz.site/post/2010-04-02-one-line-statistics/</link><pubDate>Fri, 02 Apr 2010 13:05:52 +0000</pubDate><guid>http://alperyilmaz.site/post/2010-04-02-one-line-statistics/</guid><description>&lt;p>Let&amp;rsquo;s assume we have a file with five columns where first column is text and rest of the columns are numeric. How can we calculate the standard deviation (or other statistical functions) with a perl one-liner?&lt;/p>
&lt;p>We&amp;rsquo;ll use &lt;a href="http://search.cpan.org/~shlomif/Statistics-Descriptive-3.0100/lib/Statistics/Descriptive.pm" target="_blank" rel="noopener">Statistics::Descriptive&lt;/a> module.&lt;/p>
&lt;pre>&lt;code class="language-bash">perl -MStatistics::Descriptive -ane 'BEGIN{our $stat = Statistics::Descriptive::Full-&amp;gt;new}; $stat-&amp;gt;add_data(@F[1..4]); print $stat-&amp;gt;standard_deviation,&amp;quot;\n&amp;quot;; $stat-&amp;gt;clear' filename
&lt;/code>&lt;/pre>
&lt;p>&lt;code>$stat-&amp;gt;clear&lt;/code> at the end was needed since data is added not assigned to $stat each time, so in order to prevent cumulative calculation, &lt;code>$stat&lt;/code> variable should be cleared each time.&lt;/p></description></item><item><title>perl one-liner to process sequence files in stream</title><link>http://alperyilmaz.site/post/2010-04-01-perl-one-liner-to-process-sequence-files-in-stream/</link><pubDate>Thu, 01 Apr 2010 02:43:57 +0000</pubDate><guid>http://alperyilmaz.site/post/2010-04-01-perl-one-liner-to-process-sequence-files-in-stream/</guid><description>&lt;p>Need a practical way to process fasta files with Bio::SeqIO module ? Below code will print sequence id and sequence length with tab per line.&lt;/p>
&lt;pre>&lt;code class="language-bash">perl -MBio::SeqIO -e '$seq=Bio::SeqIO-&amp;gt;new(-fh =&amp;gt; \*STDIN);while ($myseq=$seq-&amp;gt;next_seq){print $myseq-&amp;gt;id,&amp;quot;\t&amp;quot;,$myseq-&amp;gt;length,&amp;quot;\n&amp;quot;;}' &amp;lt; filename
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>OR&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-bash">cat filename | perl -MBio::SeqIO -e '$seq=Bio::SeqIO-&amp;gt;new(-fh =&amp;gt; \*STDIN);while ($myseq=$seq-&amp;gt;next_seq){print $myseq-&amp;gt;id,&amp;quot;\t&amp;quot;,$myseq-&amp;gt;length,&amp;quot;\n&amp;quot;;}'
&lt;/code>&lt;/pre>
&lt;p>There are many more methods to use from &lt;a href="http://doc.bioperl.org/releases/bioperl-current/bioperl-live/Bio/Seq.html" target="_blank" rel="noopener">Bio::Seq&lt;/a>, such as revcom, translate, subseq(start,end), primary_id, desc, etc.&lt;/p>
&lt;p>Piped file does not need to be in Fasta format, there are many other formats (listed &lt;a href="http://www.bioperl.org/wiki/HOWTO:SeqIO" target="_blank" rel="noopener">here&lt;/a>) which SeqIO can parse successfully.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>UPDATE&lt;/em>: If you are using this one-liner in a pipe, you might need to declare the format so that the stream is processed correctly. Also, in order to retrieve Bio::Seq methods, please use &amp;ldquo;-&amp;gt;seq&amp;rdquo; to access the final sequence.&lt;/p>
&lt;p>Considering all these updates, the one-liner should look like this:&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code class="language-bash">perl -MBio::SeqIO -e '$seq=Bio::SeqIO-&amp;gt;new(-fh =&amp;gt; \*STDIN,-format=&amp;gt;&amp;quot;fasta&amp;quot;);while ($myseq=$seq-&amp;gt;next_seq){print $myseq-&amp;gt;id,&amp;quot;\t&amp;quot;,$myseq-&amp;gt;length,&amp;quot;\t&amp;quot;,$myseq-&amp;gt;seq,&amp;quot;\t&amp;quot;,$myseq-&amp;gt;translate-&amp;gt;seq,&amp;quot;\n&amp;quot;;}'
&lt;/code>&lt;/pre></description></item><item><title>Top ten occurrences with perl one-liner</title><link>http://alperyilmaz.site/post/2010-03-30-top-ten-occurrences-with-perl-one-liner/</link><pubDate>Tue, 30 Mar 2010 13:56:19 +0000</pubDate><guid>http://alperyilmaz.site/post/2010-03-30-top-ten-occurrences-with-perl-one-liner/</guid><description>&lt;p>Very nice perl one-liner using map, sort and array range to show top ten occurrences&lt;/p>
&lt;p>Taken from &lt;a href="http://www.sakana.fr/blog/2010/03/02/perl-counting-occurences-of-ip-addresses-in-apache-logs/" target="_blank" rel="noopener">Tech@Sakana blog&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-bash">perl -ane '$c{$F[0]}++; END {print map {$_ . &amp;quot;\t-&amp;gt;\t&amp;quot; . $c{$_} . &amp;quot;\n&amp;quot;} (sort {$c{$b} &amp;lt;=&amp;gt; $c{$a}} keys %c)[0..9]}' filename
&lt;/code>&lt;/pre>
&lt;p>Same thing can be achieved by:&lt;/p>
&lt;pre>&lt;code class="language-bash">sort filename | uniq -c | sort -nr | head
&lt;/code>&lt;/pre>
&lt;p>But the perl one-liner demonstrates the nice combination of sort and map.&lt;/p></description></item><item><title>perl one-liner to change table layout with Hash-of-Hash-of-Array</title><link>http://alperyilmaz.site/post/2010-03-25-perl-one-liner-to-change-table-layout-with-hash-of-hash-of-array/</link><pubDate>Thu, 25 Mar 2010 01:42:53 +0000</pubDate><guid>http://alperyilmaz.site/post/2010-03-25-perl-one-liner-to-change-table-layout-with-hash-of-hash-of-array/</guid><description>&lt;p>I really like one-liners which can do a lot in a single line.. I wanted to share one I just used to arrange a big table.&lt;/p>
&lt;p>In the list of proteins below, only two proteins are shown, one protein has multiple attributes for 4 categories (InterPro, Cellular Component, Biological Process and Molecular Function). The other thing to notice is that, not all proteins have to have all the attributes, for instance, one protein might miss BiologicalProcess attribute.&lt;/p>
&lt;table style="border-collapse: collapse;" border="1" cellpadding="2" cellspacing="2">
&lt;tr>
&lt;td>
protein1
&lt;/td>
&lt;pre>&lt;code>&amp;lt;td&amp;gt;
Interpro
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
kinase
&amp;lt;/td&amp;gt;
&lt;/code>&lt;/pre>
&lt;/tr>
&lt;tr>
&lt;td>
protein1
&lt;/td>
&lt;pre>&lt;code>&amp;lt;td&amp;gt;
BiologicalProcess
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
protein folding
&amp;lt;/td&amp;gt;
&lt;/code>&lt;/pre>
&lt;/tr>
&lt;tr>
&lt;td>
protein1
&lt;/td>
&lt;pre>&lt;code>&amp;lt;td&amp;gt;
BiologicalProcess
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
metabolic process
&amp;lt;/td&amp;gt;
&lt;/code>&lt;/pre>
&lt;/tr>
&lt;tr>
&lt;td>
protein1
&lt;/td>
&lt;pre>&lt;code>&amp;lt;td&amp;gt;
MolecularFunction
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
DNA binding
&amp;lt;/td&amp;gt;
&lt;/code>&lt;/pre>
&lt;/tr>
&lt;tr>
&lt;td>
protein1
&lt;/td>
&lt;pre>&lt;code>&amp;lt;td&amp;gt;
CellularComponent
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
membrane
&amp;lt;/td&amp;gt;
&lt;/code>&lt;/pre>
&lt;/tr>
&lt;tr>
&lt;td>
protein2
&lt;/td>
&lt;pre>&lt;code>&amp;lt;td&amp;gt;
Interpro
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
transferase
&amp;lt;/td&amp;gt;
&lt;/code>&lt;/pre>
&lt;/tr>
&lt;tr>
&lt;td>
protein2
&lt;/td>
&lt;pre>&lt;code>&amp;lt;td&amp;gt;
Interpro
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
Methyltransferase
&amp;lt;/td&amp;gt;
&lt;/code>&lt;/pre>
&lt;/tr>
&lt;tr>
&lt;td>
protein2
&lt;/td>
&lt;pre>&lt;code>&amp;lt;td&amp;gt;
CellularComponent
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
membrane
&amp;lt;/td&amp;gt;
&lt;/code>&lt;/pre>
&lt;/tr>
&lt;tr>
&lt;td>
protein2
&lt;/td>
&lt;pre>&lt;code>&amp;lt;td&amp;gt;
CellularComponent
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
integral to membrane
&amp;lt;/td&amp;gt;
&lt;/code>&lt;/pre>
&lt;/tr>
&lt;/table>
&lt;p>Out of this table, I&amp;rsquo;m trying to get the following table:&lt;/p>
&lt;table style="border-collapse: collapse;" border="1" cellpadding="2" cellspacing="2">
&lt;tr>
&lt;td >
ProteinID
&lt;/td>
&lt;pre>&lt;code>&amp;lt;td &amp;gt;
InterPro
&amp;lt;/td&amp;gt;
&amp;lt;td &amp;gt;
Cellular Component
&amp;lt;/td&amp;gt;
&amp;lt;td &amp;gt;
Biological Process
&amp;lt;/td&amp;gt;
&amp;lt;td &amp;gt;
Molecular Function
&amp;lt;/td&amp;gt;
&lt;/code>&lt;/pre>
&lt;/tr>
&lt;tr>
&lt;td >
protein1
&lt;/td>
&lt;pre>&lt;code>&amp;lt;td &amp;gt;
kinase
&amp;lt;/td&amp;gt;
&amp;lt;td &amp;gt;
membrane
&amp;lt;/td&amp;gt;
&amp;lt;td &amp;gt;
protein folding; metabolic process
&amp;lt;/td&amp;gt;
&amp;lt;td &amp;gt;
DNA binding
&amp;lt;/td&amp;gt;
&lt;/code>&lt;/pre>
&lt;/tr>
&lt;tr>
&lt;td >
protein2
&lt;/td>
&lt;pre>&lt;code>&amp;lt;td &amp;gt;
transferase; Methyltransferase
&amp;lt;/td&amp;gt;
&amp;lt;td &amp;gt;
membrane; integral to membrane
&amp;lt;/td&amp;gt;
&amp;lt;td &amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td &amp;gt;
&amp;lt;/td&amp;gt;
&lt;/code>&lt;/pre>
&lt;/tr>
&lt;/table>
&lt;p>Do you think this is possible with perl one-liner? Yes, it is..&lt;/p>
&lt;p>Below is the code (suppose that Table 1 is in file called &lt;code>GeneCategories.txt&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-bash">perl -F&amp;quot;\t&amp;quot; -ane 'chomp($F[2]); push @{$hash-&amp;gt;{$F[0]}-&amp;gt;{$F[1]}},$F[2]; END {foreach $id (sort keys %$hash){print $id,&amp;quot;\t&amp;quot;; foreach $field qw(Interpro CellularComponent BiologicalProcess MolecularFunction){print join &amp;quot;;&amp;quot;,@{$hash-&amp;gt;{$id}-&amp;gt;{$field}}; print &amp;quot;\t&amp;quot;;}; print &amp;quot;\n&amp;quot;; } }' GeneCategories.txt
&lt;/code>&lt;/pre>
&lt;p>Let&amp;rsquo;s breakdown the code now. As we know, you can run perl code within terminal in this format:&lt;/p>
&lt;pre>&lt;code class="language-bash">perl -e 'code'
&lt;/code>&lt;/pre>
&lt;p>If you want to run your code in a loop, then -n option should be used. In that case, either a filename should be provided or data should be piped to perl. Auto split can be turned on by -a option which will assign split elements to an array named @F.&lt;/p>
&lt;p>If I don&amp;rsquo;t indicate that TAB is the separator, then SPACE or TAB is considered as separator. Since my data contains SPACE, I should specifically indicate that TAB is the separator by &lt;code>-F&lt;/code> option.&lt;/p>
&lt;p>One more thing about running perl in commandline with &lt;code>-n&lt;/code> option. Suppose you wish to run additional code before and/or after the loop, then you should use the following format:&lt;/p>
&lt;pre>&lt;code class="language-bash">perl -ne 'BEGIN {code1}; code2; END {code3}' filename
&lt;/code>&lt;/pre>
&lt;p>In this particular example, code1 will run before looping thru lines of filename and code3 will run after loop ended.&lt;/p>
&lt;p>Okay, now the meaning of the actual code:&lt;/p>
&lt;pre>&lt;code class="language-perl">chomp($F[2])
&lt;/code>&lt;/pre>
&lt;p>Last column contains newline character at the end, I am removing it so that final output is not bad.&lt;/p>
&lt;pre>&lt;code class="language-perl">push @{$hash-&amp;gt;{$F[0]}-&amp;gt;{$F[1]}},$F[2]
&lt;/code>&lt;/pre>
&lt;p>This is the core part where one protein can have multiple categories (Hash of hash) and one category can hold multiple values in an array (Hash of hash of array). Whatever is in third column is pushed into an array referred by hash of hash &lt;code>$hash-&amp;gt;{ProteinNo}-&amp;gt;{Category}&lt;/code>&lt;/p>
&lt;p>After loop ended, hash structure is printed and mission accomplished..&lt;/p></description></item></channel></rss>