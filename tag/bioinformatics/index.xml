<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bioinformatics | Assoc.Prof.Dr. Alper YILMAZ</title><link>http://alperyilmaz.site/tag/bioinformatics/</link><atom:link href="http://alperyilmaz.site/tag/bioinformatics/index.xml" rel="self" type="application/rss+xml"/><description>bioinformatics</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Â© 2021</copyright><lastBuildDate>Sun, 06 Mar 2011 08:40:36 +0000</lastBuildDate><image><url>http://alperyilmaz.site/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_3.png</url><title>bioinformatics</title><link>http://alperyilmaz.site/tag/bioinformatics/</link></image><item><title>Extract upstream region sequence with bedtools</title><link>http://alperyilmaz.site/post/2011-03-06-extract-upstream-region-sequence-with-bedtools/</link><pubDate>Sun, 06 Mar 2011 08:40:36 +0000</pubDate><guid>http://alperyilmaz.site/post/2011-03-06-extract-upstream-region-sequence-with-bedtools/</guid><description>&lt;p>Soon after SAM/BAM format became standard for short-read alignment softwares, high caliber tools have been emerging that can process the widely accepted format. &lt;a href="http://code.google.com/p/bedtools/" target="_blank" rel="noopener">bedtools&lt;/a> is one of them and it&amp;rsquo;s easy to use and flexible. Most importantly you can integrate it with commandline pipes.&lt;/p>
&lt;p>In this post, I&amp;rsquo;ll be describing how to extract upstream region sequences with the help of bedtools. I&amp;rsquo;ll be using the following files in my sample:&lt;/p>
&lt;p>File1: small-chr-genes.bed (holds locations of genes)&lt;/p>
&lt;pre>&lt;code class="language-txt">1 10 20 gene1 0 +
1 40 50 gene2 0 -
&lt;/code>&lt;/pre>
&lt;p>File2: small-chr.fa (genome sequence file)&lt;/p>
&lt;pre>&lt;code class="language-txt">&amp;gt;1
GCGACTACGACTACAGCACTACGACATCAGCACTACGACT
ACGACTACGACATCACGACACACGACGACATCACGACTAC
&lt;/code>&lt;/pre>
&lt;p>File3: small-chr.genome (genome file which contains name and length of each chromosome)&lt;/p>
&lt;pre>&lt;code class="language-txt">1 80
&lt;/code>&lt;/pre>
&lt;p>The one-liner below extracts 5 basepairs upstream region for each gene and slopBed takes care of strand issues (reverse complement of extracted sequence if gene is on negative strand) and genome size issues (trim the extracted sequence if gene is close to beginning or end of chromosome).&lt;/p>
&lt;pre>&lt;code class="language-bash">slopBed -i small-chr-genes.bed -g small-chr.genome -l 5 -r 0 -s | perl -ane '($F[5] eq &amp;quot;+&amp;quot;)? $F[2]=$F[1] : $F[1]=$F[2]; print join&amp;quot;\t&amp;quot;,@F;print&amp;quot;\n&amp;quot;' | slopBed -i stdin -g small-chr.genome -l 0 -r 5 -s | fastaFromBed -fi small-chr.fa -bed stdin -fo stdout -name -s
&lt;/code>&lt;/pre>
&lt;p>The output looks like this:&lt;/p>
&lt;pre>&lt;code class="language-txt">&amp;gt;gene1
TACGA
&amp;gt;gene2
TGATG
&lt;/code>&lt;/pre>
&lt;p>Let me try to explain how it works, first I extend each gene 5 basepair to its upstream. Then I mark the beginning of the extended region by converting it into single nucleotide region. I use slopBed again, to extend from the mark in opposite direction for 5 basepairs. Now we have the upstream region start and end coordinates, and by the help of fastaFromBed, the upstream region sequence was extracted from genome sequence.&lt;/p>
&lt;p>bedtools has a tool named subtractBed and I was thinking that combination of slopBed, subtractBed and fastaFromBed should be the solution. However, probably due to genes that are overlapping, subtracting gene region from extended region didn&amp;rsquo;t work as well as I expected. That&amp;rsquo;s why I integrated a perl one-liner to take care of subtracting the gene region from extended region.&lt;/p>
&lt;p>&lt;strong>Update&lt;/strong> : bedtools developer &lt;a href="http://obx.cphg.virginia.edu/quinlan/" target="_blank" rel="noopener">Aaron Quinlan&lt;/a> was kind enough to develop a new tool to accomplish the task described above. &amp;ldquo;flankBed&amp;rdquo; does exactly what is described above and it&amp;rsquo;s much simpler. Here&amp;rsquo;s the flankBed equivalent of extracting upstream regions:&lt;/p>
&lt;pre>&lt;code class="language-bash">flankBed -i small-chr-genes.bed -g small-chr.genome -l 5 -r 0 -s | fastaFromBed -fi small-chr.fa -bed stdin -fo stdout -name -s
&lt;/code>&lt;/pre></description></item><item><title>perl one-liner to pick random sequences from fasta file</title><link>http://alperyilmaz.site/post/2010-07-15-perl-one-liner-to-pick-random-sequences-from-fasta-file/</link><pubDate>Thu, 15 Jul 2010 08:03:53 +0000</pubDate><guid>http://alperyilmaz.site/post/2010-07-15-perl-one-liner-to-pick-random-sequences-from-fasta-file/</guid><description>&lt;p>In an earlier [post]({{ ref &amp;ldquo;post/perl-one-liner-to-process-sequence-files-in-stream.md&amp;rdquo; }}) we learned how to use Bio::SeqIO module to process fasta files with one-liner. Let&amp;rsquo;s do more with this capability. What about selecting random sequences from a fasta file?&lt;/p>
&lt;p>To achieve that, we&amp;rsquo;ll load the fasta file contents into a hash and then utilize the fact that &lt;code>rand(@array)&lt;/code> returns index of a random element from that array.&lt;/p>
&lt;p>Let&amp;rsquo;s pick 100 random sequences from a fasta file with one-liner:&lt;/p>
&lt;pre>&lt;code class="language-bash">.. fasta file stream .. | perl -MBio::SeqIO -e '$seq=Bio::SeqIO-&amp;gt;new(-fh =&amp;gt; \*STDIN);while ($myseq=$seq-&amp;gt;next_seq){ $hash{$myseq-&amp;gt;id}=$myseq-&amp;gt;seq }; END{@ids = keys %hash; foreach (1..100){my $index=rand(@ids); print &amp;quot;&amp;gt;&amp;quot;,$ids[$index],&amp;quot;\n&amp;quot;,$hash{$ids[$index]},&amp;quot;\n&amp;quot; } }'
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>UPDATE&lt;/strong>: If this one-liner throws problem about first sequence, please indicate the format of the input. Since read ahead is not possible in a pipe, the format might not be guessed correctly. So, please update the one-liner with this: &lt;code>$seq=Bio::SeqIO-&amp;gt;new(-fh =&amp;gt; \*STDIN, -format=&amp;gt;&amp;quot;fasta&amp;quot;)&lt;/code>&lt;/p></description></item><item><title>Visualize Circos images with Seadragon</title><link>http://alperyilmaz.site/post/2010-04-02-visualize-circos-images-with-seadragon/</link><pubDate>Fri, 02 Apr 2010 16:34:41 +0000</pubDate><guid>http://alperyilmaz.site/post/2010-04-02-visualize-circos-images-with-seadragon/</guid><description>&lt;p>&lt;a href="http://mkweb.bcgsc.ca/circos/" target="_blank" rel="noopener">Circos&lt;/a> is a very powerful tool to visualize different types of data (expression, homology, etc) in circular fashion.&lt;/p>
&lt;p>The software is capable of producing very large images if desired, suitable for posters.&lt;/p>
&lt;p>Actually, we can create large images for viewing online, since it&amp;rsquo;s trivial to view them with Seadragon.&lt;/p>
&lt;p>Below is an example from Circos tutorial (I modified the config file to obtain large image) (&lt;em>EDIT: Since the seadragon page was very slow to respond, I just included the embed URL&lt;/em>S)&lt;/p>
&lt;pre>&lt;code class="language-html">&amp;lt;script src=&amp;quot;http://seadragon.com/embed/yhz.js?width=auto&amp;amp;height=400px&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Original image is located &lt;a href="http://alperyilmaz.site/img/circos-tutorial-huge.png">here&lt;/a>.&lt;/p>
&lt;p>PS: Author of Circos, Martin Krzywinski has more interesting software listed in &lt;a href="http://mkweb.bcgsc.ca/" target="_blank" rel="noopener">his page&lt;/a>. And his lecture notes on &lt;a href="http://mkweb.bcgsc.ca/perlworkshop/index.mhtml?code=2.1.2.4" target="_blank" rel="noopener">Data Mining and Analysis at the Command Line&lt;/a> is worth checking.&lt;/p></description></item><item><title>perl one-liner to process sequence files in stream</title><link>http://alperyilmaz.site/post/2010-04-01-perl-one-liner-to-process-sequence-files-in-stream/</link><pubDate>Thu, 01 Apr 2010 02:43:57 +0000</pubDate><guid>http://alperyilmaz.site/post/2010-04-01-perl-one-liner-to-process-sequence-files-in-stream/</guid><description>&lt;p>Need a practical way to process fasta files with Bio::SeqIO module ? Below code will print sequence id and sequence length with tab per line.&lt;/p>
&lt;pre>&lt;code class="language-bash">perl -MBio::SeqIO -e '$seq=Bio::SeqIO-&amp;gt;new(-fh =&amp;gt; \*STDIN);while ($myseq=$seq-&amp;gt;next_seq){print $myseq-&amp;gt;id,&amp;quot;\t&amp;quot;,$myseq-&amp;gt;length,&amp;quot;\n&amp;quot;;}' &amp;lt; filename
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>OR&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-bash">cat filename | perl -MBio::SeqIO -e '$seq=Bio::SeqIO-&amp;gt;new(-fh =&amp;gt; \*STDIN);while ($myseq=$seq-&amp;gt;next_seq){print $myseq-&amp;gt;id,&amp;quot;\t&amp;quot;,$myseq-&amp;gt;length,&amp;quot;\n&amp;quot;;}'
&lt;/code>&lt;/pre>
&lt;p>There are many more methods to use from &lt;a href="http://doc.bioperl.org/releases/bioperl-current/bioperl-live/Bio/Seq.html" target="_blank" rel="noopener">Bio::Seq&lt;/a>, such as revcom, translate, subseq(start,end), primary_id, desc, etc.&lt;/p>
&lt;p>Piped file does not need to be in Fasta format, there are many other formats (listed &lt;a href="http://www.bioperl.org/wiki/HOWTO:SeqIO" target="_blank" rel="noopener">here&lt;/a>) which SeqIO can parse successfully.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>UPDATE&lt;/em>: If you are using this one-liner in a pipe, you might need to declare the format so that the stream is processed correctly. Also, in order to retrieve Bio::Seq methods, please use &amp;ldquo;-&amp;gt;seq&amp;rdquo; to access the final sequence.&lt;/p>
&lt;p>Considering all these updates, the one-liner should look like this:&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code class="language-bash">perl -MBio::SeqIO -e '$seq=Bio::SeqIO-&amp;gt;new(-fh =&amp;gt; \*STDIN,-format=&amp;gt;&amp;quot;fasta&amp;quot;);while ($myseq=$seq-&amp;gt;next_seq){print $myseq-&amp;gt;id,&amp;quot;\t&amp;quot;,$myseq-&amp;gt;length,&amp;quot;\t&amp;quot;,$myseq-&amp;gt;seq,&amp;quot;\t&amp;quot;,$myseq-&amp;gt;translate-&amp;gt;seq,&amp;quot;\n&amp;quot;;}'
&lt;/code>&lt;/pre></description></item></channel></rss>