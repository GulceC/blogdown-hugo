<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>commandline | Assoc.Prof.Dr. Alper YILMAZ</title><link>https://alpeyilmaz.github.io/blogdown-hugo/tag/commandline/</link><atom:link href="https://alpeyilmaz.github.io/blogdown-hugo/tag/commandline/index.xml" rel="self" type="application/rss+xml"/><description>commandline</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Â© 2021</copyright><lastBuildDate>Tue, 27 Sep 2016 00:26:05 +0300</lastBuildDate><image><url>https://alpeyilmaz.github.io/blogdown-hugo/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_3.png</url><title>commandline</title><link>https://alpeyilmaz.github.io/blogdown-hugo/tag/commandline/</link></image><item><title>Eternal bash history</title><link>https://alpeyilmaz.github.io/blogdown-hugo/post/2016-09-27-eternal-bash-history/</link><pubDate>Tue, 27 Sep 2016 00:26:05 +0300</pubDate><guid>https://alpeyilmaz.github.io/blogdown-hugo/post/2016-09-27-eternal-bash-history/</guid><description>&lt;p>After starting to use the bash, you quickly realize bash history is an invaluable asset. You can quickly search and find a previous command in order to remember when and what you have done. I was using a primitive way to archive the history with which I accumulated history of commands since 2008. The primitive setup has two parts. First part is a cron job:&lt;/p>
&lt;pre>&lt;code>0 13 3,11,24 * * /bin/cat ~/.bash_history &amp;gt; ~/.history_backup_`date +\%Y\%m\%d`
&lt;/code>&lt;/pre>
&lt;p>This cron job line means: on 3rd, 11th and 24th of each month at 1pm dump contents of &lt;code>.bash_history&lt;/code> file to history backup file. By time, I ended up with 1-2 files per month.&lt;/p>
&lt;p>Second part is couple bash functions to merge the archive.&lt;/p>
&lt;pre>&lt;code class="language-bash">oldhistory(){ for file in /home/alper/.history_backup_20*; do cat $file; echo; done | perl -ne 'if (/^#([0-9]{10}$)/){my $nextline=&amp;lt;&amp;gt;; $hash{$1}=$nextline }else{next}; END{print map { $hash{$_} } sort keys %hash}'; }
oldhistory-time(){ for file in /home/alper/.history_backup_20*; do cat $file; echo; done | perl -ne 'if (/^#([0-9]{10}$)/){ my $nextline=&amp;lt;&amp;gt;; $hash{$1}=$nextline }else{next}; END{print map {scalar localtime($_).&amp;quot;\t&amp;quot;.$hash{$_}} sort keys %hash}'; }
&lt;/code>&lt;/pre>
&lt;p>However, just recently I noticed that the bash history file is trimmed and contained only 10 days of worth commands. Luckily, I recovered a backup of &lt;code>.bash_history&lt;/code> file and didn&amp;rsquo;t lose much data. But, it was a wakeup call, my primitive system is prone to lose data without a notice. So, I started searching for a better solution to archive bash history.&lt;/p>
&lt;p>When I search online I first came across &lt;a href="https://lukas.zapletalovi.com/2013/03/never-lost-your-bash-history-again.html" target="_blank" rel="noopener">this post&lt;/a>. And then carried on searching and didn&amp;rsquo;t find anything that intrigues me. I also searched &lt;a href="https://github.com/search?o=desc&amp;amp;q=bash&amp;#43;history&amp;amp;s=stars" target="_blank" rel="noopener">Github&lt;/a> after which I got couple of aha moments. &lt;a href="https://github.com/rcaloras/bashhub-client" target="_blank" rel="noopener">Bashhub&lt;/a> can save your bash history in the cloud. That was very interesting and useful but I didn&amp;rsquo;t like the third party keeping the commands. There were couple more projects offering nice UI or advanced features (sqlite database for instance), such as &lt;a href="https://github.com/autochthe/history" target="_blank" rel="noopener">history&lt;/a>, &lt;a href="https://github.com/dvorka/hstr" target="_blank" rel="noopener">hstr&lt;/a>, &lt;a href="https://github.com/thenewwazoo/bash-history-sqlite" target="_blank" rel="noopener">bash-history-sqlite&lt;/a>.&lt;/p>
&lt;p>Finally, I got a good idea from &lt;a href="https://spin.atomicobject.com/2016/05/28/log-bash-history/" target="_blank" rel="noopener">this blog&lt;/a>. Now, I&amp;rsquo;m testing this method and hoping that it would work with less problems.&lt;/p>
&lt;pre>&lt;code class="language-bash">export PROMPT_COMMAND='history -a; history -n; if [ &amp;quot;$(id -u)&amp;quot; -ne 0 ]; then echo -e &amp;quot;$(date &amp;quot;+%Y-%m-%d.%H:%M:%S&amp;quot;)\t$(hostname)\t$(pwd)\t$(history -p \!-1)&amp;quot; &amp;gt;&amp;gt; ~/.logs/bash-history-$(hostname)-$(date &amp;quot;+%Y-%m-%d&amp;quot;).log; fi'
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>&lt;strong>Update (2017-05-26):&lt;/strong> This code causes problem with &lt;code>screen&lt;/code>. Within &lt;code>screen&lt;/code> the command is not printed out and written correctly into bash-history file.&lt;/p>
&lt;/blockquote></description></item><item><title>List of terminals with working folder names</title><link>https://alpeyilmaz.github.io/blogdown-hugo/post/2016-09-15-list-of-terminals-with-working-folder-names/</link><pubDate>Thu, 15 Sep 2016 12:00:00 +0300</pubDate><guid>https://alpeyilmaz.github.io/blogdown-hugo/post/2016-09-15-list-of-terminals-with-working-folder-names/</guid><description>&lt;p>From time to time, I had many terminal tabs open and wanted to see the list of terminals along with working folder names. Finally, I fed up with the issue tried to find a solution. After fiddling with some code, here&amp;rsquo;s the function that I added to &lt;code>.bashrc&lt;/code> file&lt;/p>
&lt;pre>&lt;code class="language-bash">tty-list() { ps aux --sort=start_time | grep &amp;quot;pts/&amp;quot; | grep [b]ash | awk -F&amp;quot; +&amp;quot; '{print $2&amp;quot;\t&amp;quot;$7}' | while read PID PTS; do echo -n -e &amp;quot;$PTS&amp;quot;&amp;quot;\t&amp;quot;; readlink -f /proc/$PID/cwd; done ; }
&lt;/code>&lt;/pre>
&lt;p>In terminal, tty-list command lists the pts number and working folder name as shown below:&lt;/p>
&lt;pre>&lt;code class="language-txt">pts/3 /home/alper
pts/6 /home/alper
pts/7 /home/alper/.logs
pts/8 /home/alper/tmp
pts/9 /home/alper/Documents/blog-github/website
pts/9 /home/alper/Documents/blog-github/website
&lt;/code>&lt;/pre>
&lt;p>The list is in order of opening the tabs. As you notice, last two lines are duplicate because when you issue the function there&amp;rsquo;s while loop and I&amp;rsquo;m guessing it&amp;rsquo;s running in a subshell so the terminal you run the function is counted twice.&lt;/p></description></item><item><title>Transpose a matrix with perl nested map</title><link>https://alpeyilmaz.github.io/blogdown-hugo/post/2011-07-07-transpose-a-matrix-with-perl-nested-map/</link><pubDate>Thu, 07 Jul 2011 09:33:37 +0000</pubDate><guid>https://alpeyilmaz.github.io/blogdown-hugo/post/2011-07-07-transpose-a-matrix-with-perl-nested-map/</guid><description>&lt;p>Here&amp;rsquo;s the matrix that we&amp;rsquo;ll be using:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ paste &amp;lt;(seq 1 5) &amp;lt;(seq 12 16)
1 12
2 13
3 14
4 15
5 16
&lt;/code>&lt;/pre>
&lt;p>Now, let&amp;rsquo;s use a perl one-liner with nested maps to transpose the matrix:&lt;/p>
&lt;pre>&lt;code class="language-bash">$ paste &amp;lt;(seq 1 5) &amp;lt;(seq 12 16) | perl -ane 'push @matrix,[@F]; END { print join &amp;quot;\n&amp;quot;,map {$row=$_; join&amp;quot;\t&amp;quot;,map { $matrix[$_][$row]} 0 .. $#matrix } 0 .. $#{$matrix[0]}; print &amp;quot;\n&amp;quot; }'
1 2 3 4 5
12 13 14 15 16
&lt;/code>&lt;/pre>
&lt;p>I got the idea from this &lt;a href="http://www.hidemail.de/blog/perl_tutor.shtml#map_transpose_matrix" target="_blank" rel="noopener">blog post&lt;/a>, but I slightly modified it so that you don&amp;rsquo;t need to make a copy of the transposed array (to save memory)&lt;/p></description></item><item><title>Extract intervals from an array of numbers</title><link>https://alpeyilmaz.github.io/blogdown-hugo/post/2011-06-27-extract-intervals-from-an-array-of-numbers/</link><pubDate>Mon, 27 Jun 2011 06:58:02 +0000</pubDate><guid>https://alpeyilmaz.github.io/blogdown-hugo/post/2011-06-27-extract-intervals-from-an-array-of-numbers/</guid><description>&lt;p>Let&amp;rsquo;s assume you have an array of numbers and you want to extract intervals from this array. For example, from such an array: 2,3,4,5,8,9,10,11,12,15,18,19,20 you should be getting (2-5), (8-12), (18-20) as intervals.&lt;/p>
&lt;p>More bioinformatic case: Let&amp;rsquo;s assume you ran samtools pileup format and want to extract intervals from the genomic coordinates that has at least one hit.&lt;/p>
&lt;p>The following one-liner will give you what you want: (I used &lt;code>seq&lt;/code> to generate array of numbers and concatenated multiple seq)&lt;/p>
&lt;pre>&lt;code class="language-bash">cat &amp;lt;(seq 3 23) &amp;lt;(echo 25) &amp;lt;(seq 40 50) | perl -ne 'BEGIN{our $i=1}; chomp ; if(($_ - (${$hash-&amp;gt;{$i-1}}[-1]))==1){push @{$hash-&amp;gt;{$i-1}},$_}else{push @{$hash-&amp;gt;{$i++}},$_}; END {print join&amp;quot;\n&amp;quot;, map {${$hash-&amp;gt;{$_}}[0].&amp;quot;\t&amp;quot;.${$hash-&amp;gt;{$_}}[-1]} grep { scalar(@{$hash-&amp;gt;{$_}}) &amp;gt; 1} sort {$a &amp;lt;=&amp;gt; $b} keys %$hash; print &amp;quot;\n&amp;quot;}'
&lt;/code>&lt;/pre>
&lt;p>And the result is:&lt;/p>
&lt;pre>&lt;code class="language-txt">3 23
40 50
&lt;/code>&lt;/pre>
&lt;p>&lt;code>map&lt;/code> was used to get first and last element of array, &lt;code>grep&lt;/code> is used to filter out arrays that has less than 2 elements.&lt;/p></description></item><item><title>Plot one-liner generated data with gnuplot</title><link>https://alpeyilmaz.github.io/blogdown-hugo/post/2010-10-16-plot-one-liner-generated-data-with-gnuplot/</link><pubDate>Sat, 16 Oct 2010 22:13:24 +0000</pubDate><guid>https://alpeyilmaz.github.io/blogdown-hugo/post/2010-10-16-plot-one-liner-generated-data-with-gnuplot/</guid><description>&lt;p>In this post, I&amp;rsquo;ll demonstrate how to use gnuplot in a one-liner. We&amp;rsquo;ll use the pipe but unfortunately you cannot pipe raw data to gnuplot directly (as far as I know). The piped data should contain basic gnuplot commands on top. So, we&amp;rsquo;ll use the following template:&lt;/p>
&lt;pre>&lt;code class="language-bash">very-complicated-data-generating-commands | sed -e &amp;quot;1i\plot '-' &amp;quot; | gnuplot -persist
&lt;/code>&lt;/pre>
&lt;p>If you&amp;rsquo;re interested in quickly see how this works, try something simple:&lt;/p>
&lt;pre>&lt;code class="language-bash">seq 1 10 | sed -e &amp;quot;1i\plot '-'&amp;quot; | gnuplot -persist
&lt;/code>&lt;/pre>
&lt;p>Before sed command, you can write as complicated as possible command to generate data and inside sed command you can put long gnuplot commands to obtain graphs. Let&amp;rsquo;s see the counts of most used 20 commands from history (mentioned in an &lt;a href="https://alpeyilmaz.github.io/blogdown-hugo/post/2010-04-08-most-used-commands-in-history/">earlier post&lt;/a> with bar chart.&lt;/p>
&lt;pre>&lt;code class="language-bash">cat ~/.bash_history|grep -v &amp;quot;^#&amp;quot; | perl -F&amp;quot;\||&amp;lt;\(|;|\`|\\$\(&amp;quot; -alne 'foreach (@F) { print $1 if /^.*?(\w+)\b/i }' | sort | uniq -c | sort -nr | head -20 | awk '{print $2&amp;quot;\t&amp;quot;$1}' | sed -e &amp;quot;1i\set boxwidth 0.5\nset style fill solid noborder\nset xtics nomirror rotate by -60\nset format x '-%s'\nplot '-' using 2:xticlabels(1) with boxes notitle&amp;quot; | gnuplot -persist
&lt;/code>&lt;/pre>
&lt;p>Resulting image looks like this:&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="https://alpeyilmaz.github.io/blogdown-hugo/img/history-top-occur-graph550x350.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>If you want to save the output in png format, what you do is simply add the command &lt;code>set term png size 600,300&lt;/code> to your one-liner. I chose width 600px and height 300px as example. In this case, gnuplot prints the contents of png file to screen, so we need to direct it to a filename, as shown below:&lt;/p>
&lt;pre>&lt;code class="language-bash">cat ~/.bash_history|grep -v &amp;quot;^#&amp;quot; | perl -F&amp;quot;\||&amp;lt;\(|;|\`|\\$\(&amp;quot; -alne 'foreach (@F) { print $1 if /^.*?(\w+)\b/i }' | sort | uniq -c | sort -nr | head -20 | awk '{print $2&amp;quot;\t&amp;quot;$1}' | sed -e &amp;quot;1i\set term png size 600,350\nset boxwidth 0.5\nset style fill solid noborder\nset xtics nomirror rotate by -60\nset format x '-%s'\nplot '-' using 2:xticlabels(1) with boxes notitle&amp;quot; | gnuplot &amp;gt; sample_image.png
&lt;/code>&lt;/pre></description></item><item><title>bash completion for scp</title><link>https://alpeyilmaz.github.io/blogdown-hugo/post/2010-03-10-bash-completion-for-scp/</link><pubDate>Wed, 10 Mar 2010 16:30:03 +0000</pubDate><guid>https://alpeyilmaz.github.io/blogdown-hugo/post/2010-03-10-bash-completion-for-scp/</guid><description>&lt;p>I have been looking for a solution for broken bash_completion for scp command. I was thinking my ssh was not configured correctly for password-less login. But I just found out that bash completion is broken for Ubuntu 9.10.&lt;/p>
&lt;p>If you are suffering from same symptom, please read &lt;a href="http://pro.grammatic.org/post-fixing-scp-completion-in-ubuntu-910-73.aspx" target="_blank" rel="noopener">this article&lt;/a> for fix.&lt;/p></description></item><item><title>Retrieve WP categories from commandline</title><link>https://alpeyilmaz.github.io/blogdown-hugo/post/2010-01-13-retrieve-wp-categories-from-commandline/</link><pubDate>Wed, 13 Jan 2010 19:08:15 +0000</pubDate><guid>https://alpeyilmaz.github.io/blogdown-hugo/post/2010-01-13-retrieve-wp-categories-from-commandline/</guid><description>&lt;p>Posting to WP from commandline is great. Before I post it, I need to lookup available categories so that I can categorize the new post correctly. To prevent a visit to WP admin GUI, I used the same Perl module for posting to retrieve available categories. Below is the code. I hope it helps you too..&lt;/p>
&lt;pre>&lt;code class="language-perl">use WordPress::XMLRPC;
my $o = WordPress::XMLRPC-&amp;gt;new({
username =&amp;gt; 'username',
password =&amp;gt; 'password',
proxy =&amp;gt; 'http://yourblog-address/xmlrpc.php',
});
my $categories= $o-&amp;gt;getCategories();
foreach (0..scalar(@$categories)) {
print ${$categories}[$_]-&amp;gt;{'categoryId'},&amp;quot;\t&amp;quot;,${$categories}[$_]-&amp;gt;{'categoryName'};
if (${$categories}[$_]-&amp;gt;{'parentId'} != 0){
print &amp;quot;\tParentId=&amp;quot;,${$categories}[$_]-&amp;gt;{'parentId'},&amp;quot;\n&amp;quot;;
}
else {print &amp;quot;\n&amp;quot;}
}
&lt;/code>&lt;/pre></description></item></channel></rss>